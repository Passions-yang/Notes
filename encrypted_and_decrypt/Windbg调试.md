# Windbg调试

### 调试符号
    * 需要在windows官网上下载符号信息文件。
    * 指定加载路径
    * 就可以在调试器中查看内部函数，变量名，结构体定义等。

## 调试过程
    调试分为远程调试和内核调试
    内核模式：NET、USB、1394、COM和本地调试
###  开始调试
        可以对正在运行的程序进行附加调试，按ctrl+E快捷键可以打开一个
    应用程序，并指定参数进行调试，按F6可以从对话框中选择当前正在运行的
    附加进程进行调试。
        Windbg调试是，反汇编代码并不会停在程序入口处，会停在ntdll.dll
    中的系统中断处，所以需要在命令窗口“Alt+l”输入“:g@$exentry”转到
    程序入口。
### 控制目标程序执行命令
| 命令 | 快捷键 | 功能 |
|:---:|:------:|:----:|
| t | F8 或 F11 | 追踪执行，遇到call指令是跟进 |
| p | F10 | 单步执行，遇到call指令时路过，不跟进|
| g | F5 | 运行程序 |
| pa 地址 | | 单步到指定地址，不进入call指令 |
| ta 地址 | | 追踪到指定地址，进入到call指令 |
|....|...|...|
        因为伪寄存器$ra代表当前函数的返回地址，所以使用pa或者ta命令加上
    @$ra来走出当前函数，例： pa $ra
## 断点命令
#### 软件断点
        Windbg 有三条命令用于设置软件断点（INT3），分别是bp,bu,bm，
    其中bp是最长用的。格式如下：
```
bp[ID] [Options] [Address [Passes]] ["CommandString"]
```
    * ID：指定断点，可缺省，内核调试限制32个断点，用户模式不限。
    * Options: 可缺省。
        1、 /1 : 中断后自动删除该断点，即一次性断点。
        2、 /c ： 指定最大调用深度，大于这个深度断点不工作。
        3、 /C ： 指定最小调用深度，小于这个深度断点不工作。
    * Adress: 地址或符号，例如：MessageBoxW。
    * Passes: 忽略中断的次数，可缺省。
    * CommandString:用于指定一组命令，当中断时，WInDbg自动执行这组命令
    ，用双引号将命令包围起来，多个命令用分号分隔。  
    bp： bp断点时设置地址的断点，它设置在地址上，如果模块把该地址的指令
        移到其他地方，断点不会随之移动。
    bu：是对于符号下断点，例如：bu kernal32!GetVersion。断点和符号关联。
        地址改变，bu跟随符号移动。
    bm： 命令设置含有通配符的断点。例如："bm msvcr80d!print*"。
#### 硬件断点
    硬件断点有时间限制，但是能实现软件断点实现不了的功能，例如监控I/O。
    断点格式如下：
```
ba[ID] Access Size [Options] [Address [Passes]] ["CommandString"]
```
    * ID：指定断点，可缺省，内核调试限制32个断点，用户模式不限。
    * Access: 指定断点触发断点的访问方式。
        1、 e ： 在读取或执行指令是触发断点。
        2、 r ： 在读取数据时触发断点。
        3、 w ： 在写入数据时，触发断点。
        4、 i ： 只执行输入/输出访问时触发断点。
    * Size: 访问的长度。
    * Address:断点的地址，地址值按照Size的值进行内存对齐。
    * CommandString:用于指定一组命令，当中断时，WInDbg自动执行这组命令
    ，用双引号将命令包围起来，多个命令用分号分隔。  
    
    限制：
        由于设置软件断点时，会修改相应的代码，所以不能调试Flash和ROM中
    的只读代码，硬件断点没有限制，因为使用的是寄存器。
#### 条件断点
#### 管理断点
| 命令 | 功能 |
|:----:|:----:|
| bl | 列出所有断点 |
| bc | 删除断点 |
| bd | 禁止断点 |
| be | 启用断点 |

### 栈窗口
#### 查看内存
d命令用于显示指定地址的内存数据，格式如下：
```
d[类型]   [地址范围]
```
| 命令 | 功能 |
|:----:|:----:|
| d 或 db | 按照字节和ASCII字符串查看 |
| da | 表示ASCII字符串 |
| dc | 按照DWORD和ASCII字符串查看|
| dd | 表示4字节DWORD格式 |
| dD | 表示8字节双精度浮点数格式 |
| df | 4字节单精度浮点数 |
| dp | 表示指针大小格式 |
| dq | 表示8字节格式 |
| du | 表示 UNicode字符串 |
| dw | 表示双字节WORD格式 |
| dW | 表示双字节WORD和ASCII格式 |
| dyb | 显示2进制和字节 |
| dyd | 显示2进制和字符串格式 |
| dt [模块名！]类型名 | 用于显示数据类型和数据结构 ，例如： dt ntdll!*|
| ds | 用于显示ANSI_STRING类型的字符串格式 |
| dS | 用于显示UNICODE_STRING类型的字符串格式 |
#### 内存搜索
s命令可以在指定的内存范围内搜索字符串,格式如下：
```
s -[type] range pattern
```
    * type:默认类型为 b
| 参数 | 意义 |
|:-:|:-:|
| b | 表示以 BYTE |
| w | WORD |
| d | DWORD |
| a | ASCII |
| u | Unicode |
    * range : 表示地址范围，可以有两种，一种是起始地址和终止地址，另一种是
            起始地址和长度。
    * pattern : 用于指定搜索内容。
    例如： s -u 400000 403000 "pediy"表示在400000H和403000H之间搜索
            Unicode字符串为"pediy"。
         s -a 0x00000000 L?0x7ffffffff mytext 表示在2GB空间内搜索ASCII
         字符串“mytext”。
#### 修改内存
e 命令用于修改指定的内存数据。
以字符串方式编辑指定地址内容，格式如下:
```
e{a|u|za|zu} address "string"
```
以数值方式编辑，格式如下：
```
e{a|b|d|D|f|q|u|w} address {values}
```
字符意义和上述其他字符意义雷同。
#### 观察内存属性
命令“!address” 用于显示指定地址的内存属性，示例如下：
```
!address [Address]
```
